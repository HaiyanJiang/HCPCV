% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/copss.R
\name{calculate_penalty}
\alias{calculate_penalty}
\title{Calculate penalty value}
\usage{
calculate_penalty(X, normalized = TRUE, penaltyform = "BIC", alph = 0, c0 = 1)
}
\arguments{
\item{X}{NumericMatrix}

\item{normalized}{bool, if we use the identity matrix \eqn{I_{p}} as the 
standardization. TRUE means we calculate another matrix and we do not have
to use the identity matrix as the scaler standardization.}

\item{penaltyform}{string, specifies the penalty form of the objective function.
"BIC", "ZOU", "", gives SMALL penalty;
"WANG", "hBIC", "CV", gives LARGE penalty.}

\item{alph}{double, pen = c0 * log(n)^(1 + alph).}

\item{c0}{double}
}
\value{
The penalty value. 
  The result of this function can be used in the OP and PELT functions.
}
\description{
Calculate penalty for the OP and PELT change detection algorithm.
}
\details{
This function calls \code{\link{trace_R_square}}, 
and it can only be called before normalization. 
The result of this function can be used in the OP and PELT function.

The penalty:
\deqn{penalty = c_0 * \log(n)^{1 + \alpha}}.

The data: 
\deqn{X_i = \mu_k + \sigma \times e_i . }
If we set  \eqn{\sigma = 0}, usually we use this kind of data to check if 
the codes of OP and PELT algorithms work fine.

The data can be generated by \code{\link{generate_1D_data}}
  \deqn{x_{i} = \mu_{j} + sig_constant * \epsilon_{i}. }
If we set \code{sig_constant = 0}, usually we use this kind of data to check 
if the codes of OP and PELT work fine.
  
NOTES1: In high dimensions, we ALWAYS need LARGE penalty. 

Notice the fact that the parameter normalized only works with 
  penaltyform = "WANG", "hBIC" and "CV". Because these three use traceR2.
  If p is large, e.g. p=400, n=200, 
  we CAN use "WANG", "hBIC", "CV" in high dimension settings.
  
NOTES2: In low dimensions, we ALWAYS need SMALL penalty.
  If p is small, we can set penaltyform ANY value, "BIC", "ZOU", "WANG", "CV".
  
NOTES3: If p is large, BUT we need SMALL penalty (in case someone want this 
  kind of setting, in practice we usually do not need this setting).
  So we can ONLY set penaltyform = "BIC", "ZOU", "", 
  however we cannot set "WANG", "hBIC" ,"CV".

EG1: when n=200, p=4, low dimension, we need SMALL values of penalty,
  such as 9 or 20, for both case of sig_constant=0, and 1. so we CAN set 
  penaltyform = any string includes "BIC", "ZOU", "WANG", "hBIC", "CV", "".
  
EG2: when n=200, p=400, high dimension, we need LARGE values of penalty, 
  such as 200, or 300, for case of sig_constant=1; 
  while for the case of sig_constant=0, we need SMALL penalty by setting 
  penaltyform = "BIC", "ZOU", "".

HOWEVER, when sig_constant=0, which is usually used for algorithm checking, 
  even though we have high dimension with p=400, we need SMALL penalty. 
  
In one word: 
\itemize{
\item{p=4, small penalty only, for both sig_constant=0 and 1; penaltyform 
  can be any string includes "BIC", "ZOU", "WANG", "hBIC" ,"CV", "";
  Both normalized=TRUE or FALSE will be fine, no difference.}
\item{p=400, large penalty for sig_constant=1, and normalized=TRUE,
  penaltyform = "WANG", "hBIC", "CV";
  If we take normalized=FALSE, no change-points will be detected.}
\item{p=400, small penalty for sig_constant=0, and normalized=FALSE,
  penaltyform = "BIC", "ZOU", "";
  If we take normalized=TRUE, no change-points will be detected.}
 }
}
